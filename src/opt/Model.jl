
abstract type Model end

struct OptModel <: Model
    objective::Tuple{Array{Sym,2},Array{Sym,1}}
    constraints::Array{Sym}
    init::Array{Float64}
    p::Parameter
end

struct FunctionGradient
    f
    grad
end

struct JuliaModel <: Model
    objective::FunctionGradient
    constraints::Array{FunctionGradient}
    init::Array{Float64}
    p::Parameter
end



function numParameters(m::Model)
    sum(m.p.n)
end

function perturbation(m::Model)
    vcat(2*rand(Float64,m.p.n[1]).-1,[0.0 for i in 1:m.p.n[2]])
end

function lower_bounds(m::Model)
    vcat([0.0 for i in 1:m.p.n[1]],[0.0 for i in 1:m.p.n[2]])
end

function upper_bounds(m::Model)
    vcat([1.0 for i in 1:m.p.n[1]],[Inf for i in 1:m.p.n[2]])
end

function get_phi(m::Model)
    get_phi(m.p)
end

#=
δ = Sym("δ")

α1 = Sym("α1")
α2 = Sym("α2")
α3 = Sym("α3")
α4 = Sym("α4")
α5 = Sym("α5")
α6 = Sym("α6")
α7 = Sym("α7")
α8 = Sym("α8")
α9 = Sym("α9")
α10 = Sym("α10")
α11 = Sym("α11")
α12 = Sym("α12")


γ1 = Sym("γ1")
γ2 = Sym("γ2")
γ3 = Sym("γ3")
γ4 = Sym("γ4")
γ5 = Sym("γ5")
γ6 = Sym("γ6")
γ7 = Sym("γ7")
=#


function build_optmodel(f,constraints,parameter,init,name,filename)

    n1 = parameter[1]
    n2 = parameter[2]
    open(filename,"w") do io

    println(io,"#generated by 'build_optmodel'\n")
    #Parameter
    println(io,"P",name,"_s = Parameter((",n1,",",n2,"))\n")

    #Objective
    println(io,"objective",name,"_s_C = ",f[1])
    println(io,"objective",name,"_s_u = ",f[2],"\n")
    #Constraints
    n_c = 0
    for constraint in constraints
        for c in constraint
            n_c += 1
        end
    end
    println(io,"constraints",name,"_s = Array{Sym}(undef,",n_c,")")
    i = 1;
    for constraint in constraints
        for c in constraint
            println(io,"constraints",name,"_s[",i,"] = ",c)
            i+=1
        end
    end
    println(io,"")

    #init
    for i in 1:n2
        push!(init, 1/name)
    end
    println(io,"init",name,"_s = ",init,"\n")

    println(io,"P",name,"_model_s =  OptModel((objective",name,"_s_C,objective",name,"_s_u), constraints",name,"_s, init",name,"_s, P",name,"_s)")


    end
end

function build_objective_julia(f, ϕ)

    Cu = f[1]*f[2]
    objective = sum(Cu.^2)

    fo = lambdify(objective,ϕ, use_julia_code=true, invoke_latest=false)

    g = []

    for p in ϕ
        push!(g,lambdify(diff(objective,p),ϕ, use_julia_code=true, invoke_latest=false))   
    end

    return (fo,g)
end

function build_function_julia(f, ϕ)

    fc = lambdify(f,ϕ, use_julia_code=true, invoke_latest=false)

    g = []

    for p in ϕ
        push!(g,lambdify(diff(f,p),ϕ, use_julia_code=true, invoke_latest=false))
    end

    return (fc,g)
end

function rename_function!(expr::Expr, name::String)
    if (expr.head == :function)
        expr.args[1].args[1] = Symbol(name)
    end
end

function get_function_call(expr::Expr)
    print(expr.args[1])
end

function create_gradient(g,name,io = stdout)
    print(io,name," = [")
    print(io,g[begin],",")
    for gi in g[begin+1:end-1]
        print(io,gi,",")
    end
    print(io,g[end],"]\n\n")

end

function create_julia_model(model,name,io=stdout)
    nc = length(model.constraints)
    print(io,name," = JuliaModel(FunctionGradient(objective,objective_grad),\n")
    print(io,"\t[FunctionGradient(constraint1,constraint1_grad),\n")
    for i in 2:nc-1
        print(io,"\t FunctionGradient(constraint$(i),constraint$(i)_grad),\n") 
    end 
    print(io,"\t FunctionGradient(constraint$(nc),constraint$(nc)_grad)],\n")
    print(io,"\t",model.init,",\n")
    print(io,"\tParameter(($(model.p.n[1]),$(model.p.n[2])))\n")
    print(io,"\t)\n \n")
end



function build_model_julia(model,model_name,file_name)
    open(file_name,"w") do io

        println(io,"#generated by 'build_model_julia'\n")
    
        p = get_phi(model)

        #Create Objective julia code
        (fo,go) = build_objective_julia(model.objective,p)
        #Give readable name to funtions
        rename_function!(fo,"objective")
        
        println(io,fo,"\n")
        gn = []
        for i in 1:length(go)
            name = "objective_grad$i"
            rename_function!(go[i],name)
            push!(gn,name)
            println(io,go[i],"\n")
        end
        #Collect gradient functions
        create_gradient(gn,"objective_grad",io)


        #Create Constraints
        for (i,c) in enumerate(model.constraints)
            #Creat julia code
            (fc, gc) =  build_function_julia(c,p)
            #Give readable name to funtions
            rename_function!(fc,"constraint$i")

            println(io,fc,"\n")

            gn = []

            for j in 1:length(gc)
                name = "constraint$(i)_grad$j"
                rename_function!(gc[j],name)
                push!(gn,name)
                println(io,gc[j],"\n")
            end

            create_gradient(gn,"constraint$(i)_grad",io)


        end

        create_julia_model(model,model_name,io)
    end
end

function create_cxx_function(fname,expr,iocpp = stdout,iohpp = stdout )
    #header file
    println(iohpp,"double ",fname,"(const std::vector<double>& x);\n")
    #code file
    println(iocpp,"double ",fname,"(const std::vector<double>& x) {")
    println(iocpp,"\treturn ",sympy.cxxcode(expr),";")
    println(iocpp,"}\n")
end

function build_model_cxx(model,modelname,filename)

    iohpp = open("$(filename).hpp","w") 
    iocpp = open("$(filename).cpp","w")
    
    println(iocpp,"//generated by 'build_model_cxx'\n")
    println(iohpp,"//generated by 'build_model_cxx'\n")
    #headers
    println(iocpp,"#include \"$(filename).hpp\"\n")

    println(iohpp,"#ifndef $(filename)_HPP")
    println(iohpp,"#define $(filename)_HPP\n")
    println(iohpp,"#include \"model.hpp\"\n")

    phi = get_phi(model)
    #sub parameter to element of x
    subx = [phi[i] => Sym("x[$(i-1)]") for i in 1:length(phi)]
    #Create objective function
    Cu = model.objective[1]*model.objective[2]
    objective = sum(Cu.^2)
        
    #create objective function
    expr = subs(objective,subx...)
    create_cxx_function("objective",expr,iocpp,iohpp)

    #create gradient of objective funtion
    for (i,p) in enumerate(phi)
        expr = subs(diff(objective,p),subx...)
        create_cxx_function("objective_grad$i",expr,iocpp,iohpp)
    end

    println(iohpp,"extern std::vector<func_t> objective_grad;\n")

    println(iocpp,"std::vector<func_t> objective_grad = {")
    n = length(phi)
    for i in 1:n-1
        println(iocpp,"\tobjective_grad$i,")
    end
    println(iocpp,"\tobjective_grad$n")
    println(iocpp,"};\n")

    #constraints
    for (j,c) in enumerate(model.constraints)
        #create constraint function
        expr = subs(c,subx...)
        create_cxx_function("constraint$j",expr,iocpp,iohpp)
        #create gradient of constraint funtion
        for (i,p) in enumerate(phi)
            expr = subs(diff(c,p),subx...)

            create_cxx_function("constraint$(j)_grad$i",expr,iocpp,iohpp)
        end

        println(iohpp,"extern std::vector<func_t> constraint$(j)_grad;\n")

        println(iocpp,"std::vector<func_t> constraint$(j)_grad = {")
        n = length(phi)
        for i in 1:n-1
            println(iocpp,"\tconstraint$(j)_grad$i,")
        end
        println(iocpp,"\tconstraint$(j)_grad$n")
        println(iocpp,"};\n")
    end

    println(iohpp,"extern Model ",modelname,";\n")

    println(iocpp,"Model ",modelname,"{")
    println(iocpp,"\t {objective,objective_grad},")
    println(iocpp,"\t {")
    n = length(model.constraints)
    for j in 1:n-1
        println(iocpp,"\t {constraint$j,constraint$(j)_grad},")
    end
    println(iocpp,"\t {constraint$n,constraint$(n)_grad}")
    println(iocpp,"\t},")
    print(iocpp,"\t {")
    n = length(model.init)
    for j in 1:n-1
        print(iocpp," ",model.init[j],",")
    end
    println(iocpp," ",model.init[n],"},")
    println(iocpp,"\tstd::make_pair($(model.p.n[1]),$(model.p.n[2]))")
    println(iocpp,"};")

    println(iohpp,"#endif /* $(filename)_HPP */")

    close(iohpp)
    close(iocpp)

end